# reusable workflow of publishing a package if local_version is not in remote_versions
name: Publish pacakge template

on:
  workflow_call:
    inputs:
      package_infos: # should meet strategy.matrix syntax with package_name & package_path
        required: true
        type: string # json string

jobs:
  publish-pkg:
    # we should put strategy inside this resulable workflow cuz using reusable workflow & strategy together is not supported yet = =
    # https://docs.github.com/en/actions/using-workflows/reusing-workflows#limitations
    strategy:
      matrix: ${{ fromJson(inputs.package_infos) }}
    name: 'package "${{ matrix.package_name }}" publish'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - uses: actions/setup-node@v2
        with:
          node-version: "20.16.0"
          registry-url: "https://npm.pkg.github.com"
          scope: "@asus-aics"

      - name: install python3
        run: sudo apt-get install -y python3

      - name: get information of local package
        id: local
        run: |
          packagePath=${{ matrix.package_path }}
          packageBaseName=${{ matrix.package_name }}

          packageName=$(cat package.json | grep name | head -1 | awk -F: '{ print $2 }' | sed 's/[",]//g' | tr -d '[[:space:]]')
          localVer=$(cat package.json | grep version | head -1 | awk -F: '{ print $2 }' | sed 's/[",]//g' | tr -d '[[:space:]]')
          isPrivate=$(cat package.json | grep private | head -1 | awk -F: '{ print $2 }' | sed 's/[",]//g' | tr -d '[[:space:]]')

          echo "package-path=$packagePath" >> $GITHUB_OUTPUT
          echo "package-basename=$packageBaseName" >> $GITHUB_OUTPUT
          echo "package-name=$packageName" >> $GITHUB_OUTPUT
          echo "local-version=$localVer" >> $GITHUB_OUTPUT
          echo "is-private=$isPrivate" >> $GITHUB_OUTPUT

      - name: get remote versions of package'
        id: remote
        run: |
          packageName=${{ steps.local.outputs.package-name }}
          remoteVers=$(npm show ${packageName} versions --json)||remoteVers=[]

          if [[ -z $remoteVers ]]; then
            remoteVers=[]
          fi

          remoteVersInOneLine=`python3 << END
          processStr = '[' + ','.join([f"'{str(ver)}'" for ver in $remoteVers]) + ']'
          print (processStr)
          END`

          echo "remote-versions=$remoteVersInOneLine" >> $GITHUB_OUTPUT
        env:
          NODE_AUTH_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}

      - name: set output for 'steps.compare.outputs.[should-release/debug-info]'
        id: compare
        run: |
          localVersion=${{ steps.local.outputs.local-version }}
          remoteVersions=${{ steps.remote.outputs.remote-versions }}
          isPrivate=${{ steps.local.outputs.is-private }}
          shouldRelease=true
          debugInfo="${debugInfo:='shouldRelease is $shouldRelease because version is not existed in registry yet.'}"

          if [[ $isPrivate = "true" ]]; then
             shouldRelease=false
             debugInfo="shouldRelease is $shouldRelease because the package is private."
          fi

          isAlreadyPublished=`python3 << END
          print (str('$localVersion' in ${{ steps.remote.outputs.remote-versions }}).lower())
          END`
          if [[ $isAlreadyPublished = "true" ]]; then
             shouldRelease=false
             debugInfo="shouldRelease is $shouldRelease because new version is already existed in registry."
          fi

          echo "should-release=$shouldRelease" >> $GITHUB_OUTPUT
          echo "debug-info=$debugInfo" >> $GITHUB_OUTPUT

      - name: echo all steps outputs for debug
        run: |
          echo "package-basename: ${{ steps.local.outputs.package-basename }}"
          echo "should-release: ${{ steps.compare.outputs.should-release }}"
          echo "debug-info: ${{ steps.compare.outputs.debug-info }}"
          echo "is-private: ${{ steps.local.outputs.is-private }}"
          echo "local-version: ${{ steps.local.outputs.local-version }}"
          echo "remote-versions: ${{ steps.remote.outputs.remote-versions }}"

      - name: build
        if: steps.compare.outputs.should-release == 'true'
        run: |
          npm install
          npm run build
        env:
          NODE_AUTH_TOKEN: ${{ secrets.PAT_R_PKG }}

      - name: publish package if version is changed and never published before
        if: steps.compare.outputs.should-release == 'true'
        run: |
          branchName=${GITHUB_REF#refs/heads/}
          packageName=${{ steps.local.outputs.package-name }}
          tag=latest

          if [[ "$branchName" == *"production"* ]]; then
            tag=latest
          elif [[ "$branchName" == *"master"* ]]; then
            tag=master-latest
          elif [[ "$branchName" == *"release"* ]]; then
            tag=release-latest
          elif [[ "$branchName" == *"hotfix"* ]]; then
            tag=hotfix-latest
          fi

          npm publish --tag $tag --dry-run
          npm publish --tag $tag

        env:
          NODE_AUTH_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}
