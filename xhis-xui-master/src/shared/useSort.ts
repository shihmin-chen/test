/* eslint-disable @typescript-eslint/no-explicit-any */
import { MaybeRef } from '@vueuse/core';
import { computed, reactive, unref } from 'vue';

export type SortPrimitive = 'string' | 'number';

export type SortFunction = (cellA: any, cellB: any) => number;

export interface SortStatus {
  /** Index key used to sort array */
  index: string | undefined;
  /** Whether to reverse */
  reverse: boolean;
  type: SortPrimitive | SortFunction;
  /** Object key of children for deep sort */
  childrenKey?: string;
  alwaysKeepSort?: boolean;
}

/**
 * Generate sort function with given known sequence.
 *
 * @param seq Query sequence list, will generated by this map
 * @returns sort function that can be use in any sort algorithm
 */
export const generateSortFunctionFromSeq = <T>(seq: T[] = []): SortFunction => {
  const LUT: Map<T, number> = new Map(seq.map((val, idx) => [val, idx]));

  return (a: T, b: T) => (LUT.get(a) ?? -1) - (LUT.get(b) ?? -1);
};

const sortByIndex =
  (index: string, type: SortStatus['type'] = 'string') =>
  (rowA: Record<string, unknown>, rowB: Record<string, unknown>): number => {
    let cellA: string | number = rowA[index] as string;
    let cellB: string | number = rowB[index] as string;

    // if provide with custom sorting function, use it.
    if (typeof type === 'function') {
      return type(cellA, cellB);
    }

    // prepare numeric value if is number type
    if (type === 'number') {
      cellA = +cellA;
      cellB = +cellB;
    }

    if (cellA === cellB) {
      return 0;
    } else if (cellA < cellB) {
      return -1;
    }
    return 1;
  };

const useSort = <T extends Record<string, unknown>>(
  data: MaybeRef<T[]>,
  initialSort?: SortStatus,
  postSort?: SortFunction,
) => {
  const sortStatus = reactive(
    initialSort ??
      ({
        index: undefined,
        reverse: false,
        type: 'string',
      } as SortStatus),
  );

  const sort = (arrayData: T[]): T[] => {
    if (!sortStatus.index) {
      if (postSort) {
        return [...arrayData].sort(postSort);
      }
      return arrayData;
    }

    let sorted = [...arrayData].sort(
      sortByIndex(sortStatus.index, sortStatus.type),
    );
    if (sortStatus.reverse) {
      sorted.reverse();
    }

    if (postSort) {
      sorted = [...sorted].sort(postSort);
    }

    const childrenKey = sortStatus.childrenKey;
    if (childrenKey) {
      sorted = sorted.reduce(
        (preData: T[], child: T) =>
          preData.concat(
            child[childrenKey]
              ? {
                  ...child,
                  [childrenKey]: sort(child[childrenKey] as T[]), // sort next level
                }
              : child, // when children key not exist in the child
          ),
        [],
      );
    }
    return sorted;
  };

  const sortedData = computed(() => {
    return sort(unref(data) ?? []);
  });

  const handleSortChange = (
    index: string,
    type: SortStatus['type'] = 'string',
  ) => {
    // assuming usage is correct
    sortStatus.type = type;

    if (sortStatus.index === index) {
      if (sortStatus.reverse) {
        sortStatus.index = sortStatus.alwaysKeepSort
          ? sortStatus.index
          : undefined;
        sortStatus.reverse = false;
      } else {
        sortStatus.reverse = true;
      }
    } else {
      sortStatus.index = index;
      sortStatus.reverse = false;
    }
  };

  return {
    sortedData,
    sortStatus,
    handleSortChange,
  };
};

export { sortByIndex, useSort };
